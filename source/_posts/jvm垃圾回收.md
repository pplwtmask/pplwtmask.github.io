---
title: jvm垃圾回收
date: 2021-04-16 15:38:06
---


### jvm内存
#### 堆内存
java8取消了永久代以metaspace元空间代替，不占用jvm内存使用直接内存
![堆内存](./img/193612_f33ff93c_6524167.png)
* 因为虚拟机使用的垃圾回收算法是分代收集算法，所以堆内存被分为了新生代和老年代
* 新生代使用的垃圾回收算法是复制算法，所以新生代又被分为了 Eden 和Survivor；空间大小比例默认为8:2
* Survivor又被分为了form、to，这两个的空间大小比例为1:1

#### 垃圾回收的时机
**Minor GC：**
* 新创建的对象在eden区分配，内存满了触发gc，存活的对象会被复制进入from
* from内存满了触发gc，存活对象被复制进入to区，from和to互相转换（可以减少full gc的次数），每GC一次，对象的年龄就涨一岁，默认达到15岁之后就会**进入老年代**，对于晋身到老年代的年龄阈值可以通过参数 `-XX:MaxTenuringThreshold`设置

**注意：** 如果在Survivor区中相同年龄的所有对象大小总和大于Survivor区空间的一半，年龄大于或者等于这个年龄的对象将会直接**进入到老年代**（因为要保证to区是空的）

**Full GC：**
* 代码中调用`System.gc()`
* 老年代空间不足/满了(空间担保)

**空间担保：** 在新生代发生Minor GC的时候，JVM会先检查老年代中可分配的连续空间是否大于新生代所有对象的总和，如果大于，那么本次Minor GC就可以安全的执行；如果不大于，那么JVM会先去检查参数`HandlePromotionFailure`设置值是否允许空间担保失败，如果允许，JVM会继续检查老年代可分配的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，尽管这次Minor GC是有风险的，JVM也会尝试一次Minor GC；如果不允许担保失败，那么JVM直接进行Full GC


**注意：** 大对象会直接在老年代分配内存，可以通过参数`-XX:PretenureSizeThreshold`控制对象的大小，通常遇到的大对象是很长的字符串或者数组，如果分配了一大群大对象只是临时使用，生命很短暂，那么就会频繁的发生Full GC，但是此时的新生代的空间还有空闲；写代码的时候，这种情况应该避免，特别是在创建数组的时候要当心
